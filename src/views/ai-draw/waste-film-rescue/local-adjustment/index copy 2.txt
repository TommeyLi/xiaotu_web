<script setup lang="ts">
import { computed, onBeforeUnmount, onMounted, ref } from 'vue'

// ========== ç±»å‹å®šä¹‰ ==========
interface Point {
  x: number
  y: number
}

interface RectShape {
  type: 'rect'
  x: number
  y: number
  w: number
  h: number
  text?: string
}

interface CircleShape {
  type: 'circle'
  x: number
  y: number
  w: number
  h: number
  text?: string
}

interface PolygonShape {
  type: 'polygon'
  points: Point[]
  text?: string
}

type Annotation = RectShape | CircleShape | PolygonShape

type ToolType = 'rect' | 'circle' | 'polygon' | 'move'

// ========== å“åº”å¼çŠ¶æ€ ==========
const imageUrl = ref<string>('')
const originalImageObj = ref<HTMLImageElement | null>(null)
const fileInput = ref<HTMLInputElement | null>(null)
const isDraggingOver = ref<boolean>(false)
const toastMsg = ref<string>('')

// Canvas ç›¸å…³
const canvasWrapper = ref<HTMLDivElement | null>(null)
const mainCanvas = ref<HTMLCanvasElement | null>(null)
const ctx = ref<CanvasRenderingContext2D | null>(null)
const transform = ref({
  x: 0,
  y: 0,
  scale: 1,
})

// å·¥å…·çŠ¶æ€
const currentTool = ref<ToolType>('rect')
const isPanning = ref<boolean>(false)
const panStart = ref<Point>({ x: 0, y: 0 })
const isSpacePressed = ref<boolean>(false)
const isDrawing = ref<boolean>(false)
const drawStart = ref<Point>({ x: 0, y: 0 })
const currentShape = ref<Annotation | null>(null)
const polygonPoints = ref<Point[]>([])
const annotations = ref<Annotation[]>([])

// é¢„è§ˆ
const previewUrl = ref<string>('')

// ========== è®¡ç®—å±æ€§ ==========
const cursorClass = computed(() => {
  if (isPanning.value)
    return 'cursor-grabbing'
  if (currentTool.value === 'move' || isSpacePressed.value)
    return 'cursor-grab'
  return 'cursor-crosshair'
})

// ========== å·¥å…·å‡½æ•° ==========
function showToast(msg: string) {
  toastMsg.value = msg
  setTimeout(() => (toastMsg.value = ''), 2000)
}

function triggerUpload() {
  fileInput.value?.click()
}
function processFile(url: string) {
 const img = new Image()
  img.crossOrigin = 'anonymous' // å¦‚æœå›¾ç‰‡è·¨åŸŸéœ€è¦å¤„ç†
  img.onload = () => {
    imageUrl.value = url
    originalImageObj.value = img
    annotations.value = []
    polygonPoints.value = []
    resetView()
    currentTool.value = 'rect'
  }
  img.onerror = (err) => {
    console.error('å›¾ç‰‡åŠ è½½å¤±è´¥', err)
  }
  img.src = url
}

function clearImage() {
  imageUrl.value = ''
  originalImageObj.value = null
  annotations.value = []
  polygonPoints.value = []
  if (ctx.value && mainCanvas.value) {
    ctx.value.clearRect(0, 0, mainCanvas.value.width, mainCanvas.value.height)
  }
}

// ========== è§†å›¾æ“ä½œ ==========
function resetView() {
  if (!originalImageObj.value || !canvasWrapper.value)
    return
  const cw = canvasWrapper.value.clientWidth
  const ch = canvasWrapper.value.clientHeight
  const iw = originalImageObj.value.width
  const ih = originalImageObj.value.height
  const s = Math.min((cw - 40) / iw, (ch - 40) / ih)
  transform.value = {
    scale: s,
    x: (cw - iw * s) / 2,
    y: (ch - ih * s) / 2,
  }
  draw()
}

function handleWheel(e: WheelEvent) {
  if (!imageUrl.value || !mainCanvas.value)
    return
  e.preventDefault()
  const rect = mainCanvas.value.getBoundingClientRect()
  const cx = e.clientX - rect.left
  const cy = e.clientY - rect.top
  const ns = transform.value.scale - e.deltaY * 0.001
  applyZoom(cx, cy, Math.min(Math.max(0.1, ns), 10))
}

function applyZoom(cx: number, cy: number, ns: number) {
  const r = ns / transform.value.scale
  transform.value.x = cx - (cx - transform.value.x) * r
  transform.value.y = cy - (cy - transform.value.y) * r
  transform.value.scale = ns
  draw()
}

function screenToImg(sx: number, sy: number): Point {
  return {
    x: (sx - transform.value.x) / transform.value.scale,
    y: (sy - transform.value.y) / transform.value.scale,
  }
}

// ========== é¼ æ ‡äº‹ä»¶ ==========
function handleMouseDown(e: MouseEvent) {
  if (!imageUrl.value || !mainCanvas.value)
    return
  const rect = mainCanvas.value.getBoundingClientRect()
  const mx = e.clientX - rect.left
  const my = e.clientY - rect.top

  if (isSpacePressed.value || e.button === 1 || currentTool.value === 'move') {
    isPanning.value = true
    panStart.value = { x: mx - transform.value.x, y: my - transform.value.y }
    return
  }

  const ip = screenToImg(mx, my)
  if (currentTool.value === 'polygon') {
    if (polygonPoints.value.length > 0) {
      const first = polygonPoints.value[0]
      const screenFirst = {
        x: first.x * transform.value.scale + transform.value.x,
        y: first.y * transform.value.scale + transform.value.y,
      }
      if (Math.hypot(mx - screenFirst.x, my - screenFirst.y) < 15) {
        finishPolygon()
        return
      }
    }
    polygonPoints.value.push(ip)
    draw()
  }
  else {
    isDrawing.value = true
    drawStart.value = ip
    currentShape.value = {
      type: currentTool.value,
      x: ip.x,
      y: ip.y,
      w: 0,
      h: 0,
    }
  }
}

function handleMouseMove(e: MouseEvent) {
  if (!imageUrl.value || !mainCanvas.value)
    return
  const rect = mainCanvas.value.getBoundingClientRect()
  const mx = e.clientX - rect.left
  const my = e.clientY - rect.top

  if (isPanning.value) {
    transform.value.x = mx - panStart.value.x
    transform.value.y = my - panStart.value.y
    draw()
  }
  else if (isDrawing.value && currentShape.value) {
    const ip = screenToImg(mx, my)
    currentShape.value.w = ip.x - drawStart.value.x
    currentShape.value.h = ip.y - drawStart.value.y
    draw()
  }
}

function handleMouseUp() {
  if (isPanning.value) {
    isPanning.value = false
    return
  }
  if (isDrawing.value && currentShape.value) {
    isDrawing.value = false
    const shape = currentShape.value
    const valid
      = Math.abs(shape.w) > 5 || Math.abs(shape.h) > 5

    if (valid) {
      // Normalize rect
      if (shape.type === 'rect') {
        if (shape.w < 0) {
          shape.x += shape.w
          shape.w = Math.abs(shape.w)
        }
        if (shape.h < 0) {
          shape.y += shape.h
          shape.h = Math.abs(shape.h)
        }
      }
      annotations.value.push({ ...shape, text: '' })
    }
    currentShape.value = null
    draw()
  }
}

function finishPolygon() {
  if (polygonPoints.value.length < 3)
    return
  annotations.value.push({
    type: 'polygon',
    points: [...polygonPoints.value],
    text: '',
  })
  polygonPoints.value = []
  draw()
}

// ========== ç»˜åˆ¶é€»è¾‘ ==========
function draw() {
  if (!ctx.value || !mainCanvas.value || !canvasWrapper.value) {
    if (mainCanvas.value && canvasWrapper.value) {
      mainCanvas.value.width = canvasWrapper.value.clientWidth
      mainCanvas.value.height = canvasWrapper.value.clientHeight
      ctx.value = mainCanvas.value.getContext('2d')
    }
    else {
      return
    }
  }

  const c = ctx.value!
  const t = transform.value
  c.clearRect(0, 0, c.canvas.width, c.canvas.height)

  c.save()
  c.translate(t.x, t.y)
  c.scale(t.scale, t.scale)

  if (originalImageObj.value) {
    c.drawImage(originalImageObj.value, 0, 0)
  }

  c.lineWidth = 2 / t.scale
  c.font = `bold ${14 / t.scale}px Arial`
  c.textAlign = 'center'
  c.textBaseline = 'middle'

  // å·²ä¿å­˜æ ‡æ³¨
  annotations.value.forEach((a, i) => drawShape(c, a, i + 1))

  // æ­£åœ¨ç»˜åˆ¶çš„å½¢çŠ¶
  if (currentShape.value) {
    drawShape(c, currentShape.value, annotations.value.length + 1, true)
  }

  // å¤šè¾¹å½¢è¾…åŠ©çº¿
  if (polygonPoints.value.length > 0) {
    c.beginPath()
    c.strokeStyle = '#f1c40f'
    c.moveTo(polygonPoints.value[0].x, polygonPoints.value[0].y)
    polygonPoints.value.forEach(p => c.lineTo(p.x, p.y))
    c.stroke()

    polygonPoints.value.forEach((p, i) => {
      c.beginPath()
      c.fillStyle = i === 0 ? 'rgba(241,196,15,0.6)' : '#fff'
      const radius = (i === 0 ? 8 : 4) / t.scale
      c.arc(p.x, p.y, radius, 0, Math.PI * 2)
      c.fill()
      c.stroke()
    })
  }

  c.restore()
}

function drawShape(c: CanvasRenderingContext2D, s: Annotation, idx: number, isDrawingNow = false) {
  c.strokeStyle = '#f1c40f'
  c.beginPath()
  let lx = 0
  let ly = 0

  if (s.type === 'rect') {
    c.rect(s.x, s.y, s.w, s.h)
    lx = s.x
    ly = s.y
  }
  else if (s.type === 'circle') {
    c.ellipse(
      s.x + s.w / 2,
      s.y + s.h / 2,
      Math.abs(s.w / 2),
      Math.abs(s.h / 2),
      0,
      0,
      Math.PI * 2,
    )
    lx = s.x
    ly = s.y
  }
  else if (s.type === 'polygon') {
    c.moveTo(s.points[0].x, s.points[0].y)
    s.points.forEach(p => c.lineTo(p.x, p.y))
    c.closePath()
    lx = s.points[0].x
    ly = s.points[0].y
  }

  c.stroke()

  if (!isDrawingNow) {
    const scale = transform.value.scale
    c.beginPath()
    c.arc(lx, ly, 10 / scale, 0, Math.PI * 2)
    c.fillStyle = '#2c3e50'
    c.fill()
    c.fillStyle = '#fff'
    c.fillText(idx.toString(), lx, ly)
  }
}

// ========== é¢„è§ˆç”Ÿæˆ ==========
function generatePreview() {
  if (!originalImageObj.value)
    return
  showToast('æ­£åœ¨ç”Ÿæˆ...')

  const cvs = document.createElement('canvas')
  cvs.width = originalImageObj.value.width
  cvs.height = originalImageObj.value.height
  const gc = cvs.getContext('2d')!
  gc.drawImage(originalImageObj.value, 0, 0)

  gc.lineWidth = 5
  gc.font = 'bold 24px Arial'

  annotations.value.forEach((a, i) => {
    gc.strokeStyle = '#f1c40f'
    gc.beginPath()
    let lx = 0
    let ly = 0

    if (a.type === 'rect') {
      gc.rect(a.x, a.y, a.w, a.h)
      lx = a.x
      ly = a.y
    }
    else if (a.type === 'circle') {
      gc.ellipse(
        a.x + a.w / 2,
        a.y + a.h / 2,
        Math.abs(a.w / 2),
        Math.abs(a.h / 2),
        0,
        0,
        Math.PI * 2,
      )
      lx = a.x
      ly = a.y
    }
    else if (a.type === 'polygon') {
      gc.moveTo(a.points[0].x, a.points[0].y)
      a.points.forEach(p => gc.lineTo(p.x, p.y))
      gc.closePath()
      lx = a.points[0].x
      ly = a.points[0].y
    }

    gc.stroke()

    // åºå·
    gc.beginPath()
    gc.arc(lx, ly, 20, 0, Math.PI * 2)
    gc.fillStyle = '#2c3e50'
    gc.fill()
    gc.fillStyle = '#fff'
    gc.textAlign = 'center'
    gc.textBaseline = 'middle'
    gc.fillText((i + 1).toString(), lx, ly)

    // æ–‡å­—æ ‡ç­¾
    if (a.text) {
      gc.textAlign = 'left'
      const w = gc.measureText(a.text).width
      gc.fillStyle = 'rgba(0,0,0,0.7)'
      gc.fillRect(lx + 25, ly - 15, w + 20, 30)
      gc.fillStyle = '#fff'
      gc.fillText(a.text, lx + 35, ly)
    }
  })

  previewUrl.value = cvs.toDataURL('image/jpeg', 0.9)
}

// ========== ç”Ÿå‘½å‘¨æœŸ ==========
onMounted(() => {
  window.addEventListener('resize', resetView)
  window.addEventListener('keydown', handleKeyDown)
  window.addEventListener('keyup', handleKeyUp)
})

onBeforeUnmount(() => {
  window.removeEventListener('resize', resetView)
  window.removeEventListener('keydown', handleKeyDown)
  window.removeEventListener('keyup', handleKeyUp)
})

function handleKeyDown(e: KeyboardEvent) {
  if (e.code === 'Space')
    isSpacePressed.value = true
  if (e.key === 'h')
    currentTool.value = 'move'
  if (e.key === 'r')
    currentTool.value = 'rect'
  if (e.key === 'c')
    currentTool.value = 'circle'
  if (e.key === 'p')
    currentTool.value = 'polygon'
}

function handleKeyUp(e: KeyboardEvent) {
  if (e.code === 'Space')
    isSpacePressed.value = false
}

// ========== æš´éœ²æ–¹æ³• ==========
function setTool(tool: ToolType) {
  currentTool.value = tool
  polygonPoints.value = []
}

function undo() {
  annotations.value.pop()
  draw()
}

function clearAnnotations() {
  annotations.value = []
  draw()
}

function removeAnnotation(index: number) {
  annotations.value.splice(index, 1)
  draw()
}

function getToolName(tool: ToolType): string {
  const map: Record<ToolType, string> = {
    rect: 'çŸ©å½¢',
    circle: 'åœ†å½¢',
    polygon: 'å¤šè¾¹å½¢',
    move: 'ç§»åŠ¨',
  }
  return map[tool]
}
</script>

<template>
  <div id="app">
    <div class="main-container">
      <!-- å·¦ä¾§ -->
      <div class="sidebar">

        <button
          v-if="imageUrl"
          class="btn btn-outline"
          @click="clearImage"
        >
          ğŸ—‘ï¸ æ¸…ç©ºå·¥ä½œåŒº
        </button>

        <div style="flex:1" />

        <button
          class="btn btn-primary"
          style="width:100%;height:50px;font-size:16px"
          :disabled="!imageUrl"
          @click="generatePreview"
        >
          ğŸ‘ï¸ ç”Ÿæˆå¹¶é¢„è§ˆ
        </button>
      </div>

      <!-- ä¸­é—´ç”»å¸ƒ -->
      <div class="workspace">
        <div
          ref="canvasWrapper"
          class="canvas-wrapper"
          :class="cursorClass"
          @wheel.prevent="handleWheel"
          @mousedown="handleMouseDown"
          @mousemove="handleMouseMove"
          @mouseup="handleMouseUp"
          @mouseleave="handleMouseUp"
        >
          <div
            v-if="!imageUrl"
            style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#888"
          >
            è¯·å…ˆä¸Šä¼ å›¾ç‰‡
          </div>

          <canvas ref="mainCanvas" />

          <div
            v-if="imageUrl"
            class="zoom-info"
          >
            ç¼©æ”¾: {{ Math.round(transform.scale * 100) }}%
          </div>

          <div
            v-if="imageUrl"
            class="toolbar"
          >
            <div
              class="tool-btn"
              :class="{ active: currentTool === 'move' }"
              @click="setTool('move')"
            >
              âœ‹
            </div>
            <div
              class="tool-btn"
              :class="{ active: currentTool === 'rect' }"
              @click="setTool('rect')"
            >
              â¬œ
            </div>
            <div
              class="tool-btn"
              :class="{ active: currentTool === 'circle' }"
              @click="setTool('circle')"
            >
              â­•
            </div>
            <div
              class="tool-btn"
              :class="{ active: currentTool === 'polygon' }"
              @click="setTool('polygon')"
            >
              ğŸ“
            </div>
            <div
              class="tool-btn"
              @click="resetView"
            >
              ğŸ¯
            </div>
            <div
              class="tool-btn"
              @click="undo"
            >
              â†©ï¸
            </div>
            <div
              class="tool-btn"
              style="color:var(--error)"
              @click="clearAnnotations"
            >
              ğŸ—‘ï¸
            </div>
          </div>
        </div>
      </div>

      <!-- å³ä¾§æ ‡æ³¨åˆ—è¡¨ -->
      <div
        class="sidebar"
        style="border-left:1px solid var(--border);width:280px"
      >    
        <div class="panel-header">
          ğŸ“Œ æ ‡æ³¨åˆ—è¡¨ ({{ annotations.length }})
        </div>
        <div style="flex:1;overflow:auto">
          <div
            v-for="(anno, i) in annotations"
            :key="i"
            class="anno-item"
          >
            <div class="anno-idx">
              {{ i + 1 }}
            </div>
            <div style="flex:1">
              <div class="anno-header">
                <span>{{ getToolName(anno.type) }}</span>
                <span
                  class="anno-remove"
                  @click="removeAnnotation(i)"
                >âœ•</span>
              </div>
              <input
                v-model="anno.text"
                class="form-input"
                placeholder="è¾“å…¥è¯´æ˜..."
              >
            </div>
          </div>
        </div>
      </div>
    </div>

    <input
      ref="fileInput"
      type="file"
      accept="image/*"
      hidden
      @change="handleFileSelect"
    >

    <div
      v-if="toastMsg"
      class="toast"
    >
      {{ toastMsg }}
    </div>

    <!-- <div
      v-if="previewUrl"
      class="modal-mask"
      @click="previewUrl = ''"
    >
      <img
        :src="previewUrl"
        class="preview-img"
        @click.stop
      >
    </div> -->
  </div>
</template>

    <style>
:root {
  --primary: #332f1f;
  --accent: #2c3e50;
  --bg: #f5f6fa;
  --border: #e0e0e0;
  --error: #d63031;
}
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
  outline: none;
  user-select: none;
}
body {
  background: var(--bg);
  font-family: 'Noto Sans SC', sans-serif;
  height: 100vh;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  color: #333;
}

/* --- å¸ƒå±€å®¹å™¨ --- */
.main-container {
  display: flex;
  height: calc(100vh - 60px);
  width: 100%;
}

/* å·¦ä¾§è¾¹æ  */
.sidebar {
  width: 300px;
  background: #fff;
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  padding: 20px;
  gap: 20px;
  flex-shrink: 0;
  z-index: 20;
}
.upload-box {
  height: 200px;
  border: 2px dashed #ccc;
  border-radius: 12px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  background: #fafafa;
  transition: 0.2s;
  text-align: center;
  padding: 10px;
  position: relative;
  overflow: hidden;
}
.upload-box:hover,
.upload-box.dragging {
  border-color: var(--primary);
  background: #fffdf0;
}

/* é€šç”¨æ§ä»¶ */
.btn {
  padding: 12px 20px;
  border-radius: 8px;
  border: none;
  font-weight: bold;
  cursor: pointer;
  transition: 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  font-size: 14px;
}
.btn-primary {
  background: var(--primary);
  color: #2c3e50;
}
.btn-outline {
  background: #fff;
  border: 1px solid #ddd;
  color: #555;
}
.form-input {
  width: 100%;
  padding: 8px;
  border: 1px solid #ddd;
  border-radius: 6px;
}

/* å·¥ä½œåŒº */
.workspace {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  background: #e0e0e0;
  position: relative;
}
.canvas-wrapper {
  flex: 1;
  position: relative;
  overflow: hidden;
  background: #333;
}
.canvas-wrapper.cursor-crosshair {
  cursor: crosshair;
}
.canvas-wrapper.cursor-grab {
  cursor: grab;
}
.canvas-wrapper.cursor-grabbing {
  cursor: grabbing;
}

/* å·¥å…·æ  */
.toolbar {
  position: absolute;
  top: 20px;
  right: 20px;
  background: rgba(255, 255, 255, 0.95);
  padding: 8px;
  border-radius: 10px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
  display: flex;
  flex-direction: column;
  gap: 8px;
  z-index: 50;
}
.tool-btn {
  width: 40px;
  height: 40px;
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  font-size: 20px;
  color: #555;
}
.tool-btn:hover {
  background: #f0f0f0;
}
.tool-btn.active {
  background: var(--primary);
  color: #2c3e50;
}
.zoom-info {
  position: absolute;
  bottom: 20px;
  left: 20px;
  background: rgba(0, 0, 0, 0.6);
  color: #fff;
  padding: 4px 12px;
  border-radius: 20px;
  font-size: 12px;
  pointer-events: none;
}

/* æ ‡æ³¨é¢æ¿ */
.annotation-panel {
  height: 40%;
  background: #fff;
  border-top: 1px solid var(--border);
  display: flex;
  flex-direction: column;
  z-index: 20;
}
.panel-header {
  padding: 12px 15px;
  border-bottom: 1px solid #eee;
  font-weight: 700;
  font-size: 14px;
  background: #fafafa;
}
.anno-item {
  display: flex;
  gap: 10px;
  align-items: center;
  padding: 10px;
  border-bottom: 1px solid #f0f0f0;
}
.anno-idx {
  width: 20px;
  height: 20px;
  background: var(--accent);
  color: #fff;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  flex-shrink: 0;
}

.toast {
  position: fixed;
  top: 80px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.8);
  color: #fff;
  padding: 10px 24px;
  border-radius: 50px;
  font-size: 14px;
  z-index: 6000;
}
</style>
